<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns:sch="http://purl.oclc.org/dsdl/schematron"
  xmlns:crapp="http://baumann-digital.de/ns/criticalApparatus"
  xmlns:functx="http://www.functx.com"
  xmlns:mei="http://www.music-encoding.org/ns/mei"
  xmlns="http://www.tei-c.org/ns/1.0">
  <teiHeader>
    <fileDesc>
      <titleStmt>
        <title>Title</title>
      </titleStmt>
      <publicationStmt>
        <p>Publication Information</p>
      </publicationStmt>
      <sourceDesc>
        <p>Information about the source</p>
      </sourceDesc>
    </fileDesc>
  </teiHeader>
  <text>
    <body>
      <schemaSpec ident="odd-critRemarks" start="apparatus" ns="http://baumann-digital.de/ns/criticalApparatus" xmlns:mei="http://www.music-encoding.org/ns/mei">
        <classSpec type="atts" ident="att.key">
          <attList>
            <attDef ident="key">
              <datatype><dataRef key="text"/></datatype>
            </attDef>
          </attList>
        </classSpec>
        
        <classSpec type="atts" ident="att.numbering">
          <attList>
            <attDef ident="no">
              <datatype><dataRef key="integer"/></datatype>
            </attDef>
            <attDef ident="sortNo">
              <datatype><dataRef key="integer"/></datatype>
            </attDef>
          </attList>
        </classSpec>
        
        <classSpec type="atts" ident="att.timing">
          <attList>
            <attDef ident="measure">
              <datatype><dataRef key="integer"/></datatype>
            </attDef>
            <attDef ident="count">
              <datatype><dataRef key="integer"/></datatype>
            </attDef>
          </attList>
        </classSpec>
        
        <classSpec type="atts" ident="att.siglum">
          <attList>
            <attDef ident="siglum">
              <datatype><dataRef key="text"/></datatype>
            </attDef>
          </attList>
        </classSpec>
        
        <classSpec type="atts" ident="att.target">
          <attList>
            <attDef ident="target">
              <datatype><dataRef key="URI"/></datatype>
            </attDef>
          </attList>
        </classSpec>
        
        <constraintSpec ident="setting-values-check" scheme="schematron">
          <constraint>
            <sch:schema xmlns:xsl="http://www.w3.org/1999/XSL/Transform" queryBinding="xslt2">
              <sch:ns uri="http://baumann-digital.de/ns/criticalApparatus" prefix="crapp"/>
              
              <xsl:function name="functx:is-value-in-sequence" as="xs:boolean"
                xmlns:functx="http://www.functx.com">
                <xsl:param name="value" as="xs:anyAtomicType?"/>
                <xsl:param name="seq" as="xs:anyAtomicType*"/>
                <xsl:sequence select="$value = $seq"/>
              </xsl:function>
              
              <xsl:function name="crapp:checkValues">
                <xsl:param name="elem" as="node()"/>
                <xsl:param name="attName" as="xs:string"/>
                <xsl:variable name="elemName" select="local-name($elem)"/>
                <xsl:variable name="elemText" select="$elem/text()"/>
                <xsl:variable name="setVals" select="$elem/ancestor::crapp:apparatus//crapp:setting//node()[local-name()=$elemName]"/>
                <xsl:value-of select="functx:is-value-in-sequence($elemText, if($setVals/attribute::node()[local-name()=$attName])then($setVals/attribute::node()[local-name()=$attName]) else($setVals/text()))"/>
              </xsl:function>
              <xsl:function name="crapp:valuesAllowed">
                <xsl:param name="elem" as="node()"/>
                <xsl:param name="attName" as="xs:string"/>
                <xsl:variable name="elemName" select="local-name($elem)"/>
                <xsl:variable name="elemText" select="$elem/text()"/>
                <xsl:variable name="setVals" select="$elem/ancestor::crapp:apparatus//crapp:setting//node()[local-name()=$elemName]"/>
                <xsl:for-each select="$setVals">
                  <xsl:value-of select="if(attribute::node()[local-name()=$attName]) then(concat(attribute::node()[local-name()=$attName]/string(), ' (', text(), ')')) else(text())"/>
                </xsl:for-each>
              </xsl:function>
              <xsl:function name="crapp:valuesAllowedJoined">
                <xsl:param name="elem" as="node()"/>
                <xsl:param name="attName" as="xs:string"/>
                <xsl:value-of select="string-join(crapp:valuesAllowed($elem, $attName), ', ')"/>
              </xsl:function>
              
              <sch:pattern abstract="true" id="checkValues">
                <sch:rule context="crapp:remark//node()[local-name()='$elementName']"> 
                  <sch:assert test="exists(ancestor::crapp:apparatus/crapp:setting//node()[local-name()='$elementName'])" role="fatal">No setting for <sch:value-of select="local-name(.)"/> defined. Please define the setting before use.</sch:assert>
                  <sch:report test="exists(ancestor::crapp:apparatus/crapp:setting//node()[local-name()='$elementName']) and crapp:checkValues(., '$attrStr') = false()"
                    role="error">The value <sch:value-of select="."/> is not allowed here. Please use one of these: <sch:value-of select="crapp:valuesAllowedJoined(., '$attrStr')"/>.</sch:report>
                </sch:rule>
              </sch:pattern>
            </sch:schema>
          </constraint>
        </constraintSpec>
        
        <elementSpec ident="apparatus">
          <desc>Root element for the critical remarks.</desc>
          <content>
            <elementRef key="setting" minOccurs="1" maxOccurs="1"/>
            <elementRef key="remarks" minOccurs="1" maxOccurs="unbounded"/>
          </content>
          <attList>
            <attDef ident="xml:id">
              <desc>ID of the file. Must be unique in the context of this framework.</desc>
              <datatype>
                <dataRef key="ID"/>
              </datatype>
            </attDef>
          </attList>
        </elementSpec>
        
        <elementSpec ident="setting">
          <desc>Die Grundinformationen (Zugeh√∂rige Quellen, Instrumente/Stimmen, Editionen)</desc>
          <content>
            <elementRef key="mdivs"/>
            <elementRef key="voices"/>
            <elementRef key="relWorks"/>
            <elementRef key="relSources"/>
            <elementRef key="relEditions"/>
            <elementRef key="categories"/>
          </content>
        </elementSpec>
        
        <elementSpec ident="remarks">
          <content>
            <elementRef key="remark" minOccurs="1" maxOccurs="unbounded"/>
          </content>
        </elementSpec>
        <elementSpec ident="remark">
          <desc>Eine kritische Anmerkung</desc>
          <content>
            <elementRef key="category"/>
            <elementRef key="mdiv"/>
            <elementRef key="occurances" minOccurs="0" maxOccurs="1"/>
            <elementRef key="voices" maxOccurs="1"/>
<!--            <elementRef key="layers" maxOccurs="1"/>-->
            <elementRef key="annots" minOccurs="1"/>
            <elementRef key="sources" maxOccurs="1"/>
            <elementRef key="editions" maxOccurs="1"/>
          </content>
          <attList>
            <attDef ident="xml:id">
              <datatype>
                <dataRef key="ID"/>
              </datatype>
            </attDef>
            <attDef ident="type">
              <valList type="closed">
                <valItem ident="editorial">
                  <desc>Eingriff (Hg.)</desc>
                </valItem>
                <valItem ident="reading">
                  <desc>Lesart</desc>
                </valItem>
                <valItem ident="annotation">
                  <desc>Anmerkung (Hg.)</desc>
                </valItem>
              </valList>
            </attDef>
          </attList>
        </elementSpec>

        <elementSpec ident="categories">
          <content>
            <elementRef key="category" minOccurs="1" maxOccurs="unbounded"/>
          </content>
        </elementSpec>
        <elementSpec ident="category">
          <content><textNode/></content>
        </elementSpec>
        <elementSpec ident="mdivs">
          <content>
            <elementRef key="mdiv" minOccurs="1" maxOccurs="unbounded"/>
          </content>
        </elementSpec>
        <elementSpec ident="mdiv">
          <classes>
            <memberOf key="att.numbering"/>
          </classes>
          <content>
            <textNode/>
          </content>
          <constraintSpec ident="check-values-mdiv" scheme="schematron">
            <constraint>
                <sch:pattern is-a="checkValues">
                  <sch:param name="elementName" value="mdiv"/>
                  <sch:param name="attrStr" value="no"/>
                </sch:pattern>
            </constraint>
          </constraintSpec>
        </elementSpec>
        
        <elementSpec ident="occurances">
          <content>
            <elementRef key="occurance" minOccurs="1" maxOccurs="unbounded"/>
          </content>
        </elementSpec>
        
        <elementSpec ident="occurance">
          <content>
              <alternate>
                <elementRef key="position" minOccurs="1" maxOccurs="1"/>
              <sequence>
                <elementRef key="range"/>
                <elementRef key="range"/>
              </sequence>
              </alternate>
          </content>
        </elementSpec>
        <elementSpec ident="position">
          <classes>
            <memberOf key="att.timing"/>
          </classes>
        </elementSpec>
        <elementSpec ident="range">
          <classes>
            <memberOf key="att.timing"/>
          </classes>
          <constraintSpec ident="range-type-vals" scheme="schematron">
            <constraint>
              <sch:pattern>
                <sch:rule context="crapp:range">
                  <sch:assert test="parent::node()/crapp:range[1]/@type='start'">The value of @type in the first range must be 'start'</sch:assert>
                  <sch:assert test="parent::node()/crapp:range[2]/@type='stop'">The value of @type in the second range must be 'stop'</sch:assert>
                </sch:rule>
              </sch:pattern>
            </constraint>
          </constraintSpec>
          <attList>
            <attDef ident="type" usage="req">
              <valList type="closed">
                <valItem ident="start">
                  <gloss xml:lang="en">starting point</gloss>
                  <desc xml:lang="en">The location where the range of the occurance starts.</desc>
                </valItem>
                <valItem ident="stop">
                  <gloss xml:lang="en">stopping point</gloss>
                  <desc xml:lang="en">The location where the range of the occurance stops.</desc>
                </valItem>
              </valList>
            </attDef>
          </attList>
        </elementSpec>
        
        
        <elementSpec ident="voices">
          <desc>A Wrapper for voices (voice-elements)</desc>
          <content>
            <elementRef key="voice" minOccurs="1" maxOccurs="unbounded"/>
          </content>
        </elementSpec>
        <elementSpec ident="voice">
          <classes>
            <memberOf key="att.key"/>
            <memberOf key="att.numbering"/>
          </classes>
          <content>
            <textNode/>
          </content>
          <constraintSpec ident="check-values-voice" scheme="schematron">
            <constraint>
              <sch:pattern is-a="checkValues">
                <sch:param name="elementName" value="voice"/>
                <sch:param name="attrStr" value="key"/>
              </sch:pattern>
            </constraint>
          </constraintSpec>
        </elementSpec>
        <elementSpec ident="layers">
          <desc>A Wrapper for layers (layer-elements)</desc>
          <content>
            <elementRef key="layer" minOccurs="1" maxOccurs="unbounded"/>
          </content>
        </elementSpec>
        <elementSpec ident="layer">
          <content>
            <textNode/>
          </content>
          <constraintSpec ident="check-values-layer" scheme="schematron">
            <constraint>
              <sch:pattern is-a="checkValues">
                <sch:param name="elementName" value="layer"/>
                <sch:param name="attrStr" value="key"/>
              </sch:pattern>
            </constraint>
          </constraintSpec>
        </elementSpec>
        <elementSpec ident="annots">
          <desc>A Wrapper for annotations (annot-elements)</desc>
          <content>
            <elementRef key="annot" minOccurs="1" maxOccurs="unbounded"/>
            <!-- source="../../MusicEncoding/music-encoding/source/modules/MEI.shared.xml" -->
          </content>
        </elementSpec>
        <elementSpec ident="annot">
          <content>
<!--            <alternate>-->
              <textNode/>
              <!--<sequence preserveOrder="false">
                <textNode/>
                <elementRef key="app"/>
                <textNode/>
              </sequence>-->
            <!--</alternate>-->
          </content>
        </elementSpec>
        <elementSpec ident="sources">
          <desc>A Wrapper for sources (source-elements)</desc>
          <content>
            <elementRef key="source" minOccurs="1" maxOccurs="unbounded"/>
          </content>
        </elementSpec>
        <elementSpec ident="source">
          <classes>
            <memberOf key="att.numbering"/>
            <memberOf key="att.siglum"/>
            <memberOf key="att.target"/>
          </classes>
          <content>
            <textNode/>
          </content>
          <constraintSpec ident="check-values-source" scheme="schematron">
            <constraint>
              <sch:pattern is-a="checkValues">
                <sch:param name="elementName" value="source"/>
                <sch:param name="attrStr" value="siglum"/>
              </sch:pattern>
            </constraint>
          </constraintSpec>
        </elementSpec>
        <elementSpec ident="editions">
          <desc>A Wrapper for editions (edition-elements)</desc>
          <content>
            <elementRef key="edition" minOccurs="1" maxOccurs="unbounded"/>
          </content>
        </elementSpec>
        <elementSpec ident="edition">
          <classes>
            <memberOf key="att.numbering"/>
            <memberOf key="att.siglum"/>
            <memberOf key="att.target"/>
          </classes>
          <content>
            <textNode/>
          </content>
          <constraintSpec ident="check-values-edition" scheme="schematron">
            <constraint>
              <sch:pattern is-a="checkValues">
                <sch:param name="elementName" value="edition"/>
                <sch:param name="attrStr" value="siglum"/>
              </sch:pattern>
            </constraint>
          </constraintSpec>
        </elementSpec>
      </schemaSpec>
    </body>
  </text>
</TEI>
